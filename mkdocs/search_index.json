{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to RediSearch\n\n\nRediSearch is a Full-Text search over Redis, developed by RedisLabs. \n\n\nThe source code is available at \nhttps://github.com/RedisLabsModules/RediSearch\n.\n\n\nOverview\n\n\nRedisearch impements a search engine on top of redis, but unlike other redis \nsearch libraries, it does not use internal data structures like sorted sets.\n\n\nInverted indexes are stored on top of Redis strings using binary encoding,\nand not mapped to existing data structures (see \nDESIGN.md\n). \n\n\nThis allows much faster performance, significantly less memory consumption, and\nmore advanced features like exact phrase matching, that are not possible with \ntraditional redis search approaches. \n\n\nPrimary Features:\n\n\n\n\nFull-Text indexing of multiple fields in documents.\n\n\nIncremental indexing without performance loss.\n\n\nDocument ranking (provided manually by the user at index time).\n\n\nField weights.\n\n\nAuto-complete suggestions (with fuzzy prefix suggestions)\n\n\nExact Phrase Search of up to 8 words.\n\n\nStemming based query expansion in \nmany languages\n (using \nSnowball\n).\n\n\nLimiting searches to specific document fields (up to 8 fields supported).\n\n\nNumeric filters and ranges.\n\n\nGeo filtering using Redis' own Geo-commands. \n\n\nSupports any utf-8 encoded text.\n\n\nRetrieve full document content or just ids\n\n\nAutomatically index existing HASH keys as documents.\n\n\nDocument deletion.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-redisearch", 
            "text": "RediSearch is a Full-Text search over Redis, developed by RedisLabs.   The source code is available at  https://github.com/RedisLabsModules/RediSearch .", 
            "title": "Welcome to RediSearch"
        }, 
        {
            "location": "/#overview", 
            "text": "Redisearch impements a search engine on top of redis, but unlike other redis \nsearch libraries, it does not use internal data structures like sorted sets.  Inverted indexes are stored on top of Redis strings using binary encoding,\nand not mapped to existing data structures (see  DESIGN.md ).   This allows much faster performance, significantly less memory consumption, and\nmore advanced features like exact phrase matching, that are not possible with \ntraditional redis search approaches.", 
            "title": "Overview"
        }, 
        {
            "location": "/#primary-features", 
            "text": "Full-Text indexing of multiple fields in documents.  Incremental indexing without performance loss.  Document ranking (provided manually by the user at index time).  Field weights.  Auto-complete suggestions (with fuzzy prefix suggestions)  Exact Phrase Search of up to 8 words.  Stemming based query expansion in  many languages  (using  Snowball ).  Limiting searches to specific document fields (up to 8 fields supported).  Numeric filters and ranges.  Geo filtering using Redis' own Geo-commands.   Supports any utf-8 encoded text.  Retrieve full document content or just ids  Automatically index existing HASH keys as documents.  Document deletion.", 
            "title": "Primary Features:"
        }, 
        {
            "location": "/Quick_Start/", 
            "text": "Quick Start Guide for RediSearch:\n\n\nBuilding and running:\n\n\ngit clone https://github.com/RedisLabsModules/RediSearch.git\ncd RediSearch/src\nmake all\n\n# Assuming you have a redis build from the unstable branch:\n/path/to/redis-server --loadmodule ./module.so\n\n\n\n\nCreating an index with fields and weights (default weight is 1.0):\n\n\n127.0.0.1:6379\n FT.CREATE myIdx SCHEMA title TEXT WEIGHT 5.0 body TEXT url TEXT\nOK \n\n\n\n\n\nAdding documents to the index:\n\n\n127.0.0.1:6379\n FT.ADD myIdx doc1 1.0 FIELDS title \nhello world\n body \nlorem ipsum\n url \nhttp://redis.io\n \nOK\n\n\n\n\nSearching the index:\n\n\n127.0.0.1:6379\n FT.SEARCH myIdx \nhello world\n LIMIT 0 10\n1) (integer) 1\n2) \ndoc1\n\n3) 1) \ntitle\n\n   2) \nhello world\n\n   3) \nbody\n\n   4) \nlorem ipsum\n\n   5) \nurl\n\n   6) \nhttp://redis.io\n\n\n\n\n\n\n\nNOTE\n: Input is expected to be valid utf-8 or ascii. The engine cannot handle wide character unicode at the moment. \n\n\n\n\nDropping the index:\n\n\n127.0.0.1:6379\n FT.DROP myIdx\nOK\n\n\n\n\nAdding and getting Auto-complete suggestions:\n\n\n127.0.0.1:6379\n FT.SUGADD autocomplete \nhello world\n 100\nOK\n\n127.0.0.1:6379\n FT.SUGGET autocomplete \nhe\n\n1) \nhello world", 
            "title": "Quick Start"
        }, 
        {
            "location": "/Quick_Start/#quick-start-guide-for-redisearch", 
            "text": "", 
            "title": "Quick Start Guide for RediSearch:"
        }, 
        {
            "location": "/Quick_Start/#building-and-running", 
            "text": "git clone https://github.com/RedisLabsModules/RediSearch.git\ncd RediSearch/src\nmake all\n\n# Assuming you have a redis build from the unstable branch:\n/path/to/redis-server --loadmodule ./module.so", 
            "title": "Building and running:"
        }, 
        {
            "location": "/Quick_Start/#creating-an-index-with-fields-and-weights-default-weight-is-10", 
            "text": "127.0.0.1:6379  FT.CREATE myIdx SCHEMA title TEXT WEIGHT 5.0 body TEXT url TEXT\nOK", 
            "title": "Creating an index with fields and weights (default weight is 1.0):"
        }, 
        {
            "location": "/Quick_Start/#adding-documents-to-the-index", 
            "text": "127.0.0.1:6379  FT.ADD myIdx doc1 1.0 FIELDS title  hello world  body  lorem ipsum  url  http://redis.io  \nOK", 
            "title": "Adding documents to the index:"
        }, 
        {
            "location": "/Quick_Start/#searching-the-index", 
            "text": "127.0.0.1:6379  FT.SEARCH myIdx  hello world  LIMIT 0 10\n1) (integer) 1\n2)  doc1 \n3) 1)  title \n   2)  hello world \n   3)  body \n   4)  lorem ipsum \n   5)  url \n   6)  http://redis.io    NOTE : Input is expected to be valid utf-8 or ascii. The engine cannot handle wide character unicode at the moment.", 
            "title": "Searching the index:"
        }, 
        {
            "location": "/Quick_Start/#dropping-the-index", 
            "text": "127.0.0.1:6379  FT.DROP myIdx\nOK", 
            "title": "Dropping the index:"
        }, 
        {
            "location": "/Quick_Start/#adding-and-getting-auto-complete-suggestions", 
            "text": "127.0.0.1:6379  FT.SUGADD autocomplete  hello world  100\nOK\n\n127.0.0.1:6379  FT.SUGGET autocomplete  he \n1)  hello world", 
            "title": "Adding and getting Auto-complete suggestions:"
        }, 
        {
            "location": "/Commands/", 
            "text": "RediSeach Full Command Documentation\n\n\nFT.CREATE\n\n\nFormat:\n\n\n  FT.CREATE {index} \n    [NOOFFSETS] [NOFIELDS] [NOSCOREIDX]\n    SCHEMA {field} [TEXT [WEIGHT {weight}] | NUMERIC | GEO] ...\n\n\n\n\nDescription:\n\n\nCreates an index with the given spec. The index name will be used in all the key names\nso keep it short!\n\n\nParameters:\n\n\n\n\n\n\nindex\n: the index name to create. If it exists the old spec will be overwritten\n\n\n\n\n\n\nNOOFFSETS\n: If set, we do not store term offsets for documents (saves memory, does not allow exact searches)\n\n\n\n\n\n\nNOFIELDS\n: If set, we do not store field bits for each term. Saves memory, does not allow filtering by specific fields.\n\n\n\n\n\n\nNOSCOREIDX\n: If set, we avoid saving the top results for single words. Saves a lot of memory, slows down searches for common single word queries.\n\n\n\n\n\n\nSCHEMA {field} {options...}\n: After the SCHEMA keyword we define the index fields. \nThey can be numeric, textual or geographical. For textual fields we optionally specify a weight. The default weight is 1.0.\n\n\n\n\n\n\nComplexity\n\n\nO(1)\n\n\nReturns:\n\n\nOK or an error\n\n\n\n\nFT.ADD\n\n\nFormat:\n\n\nFT.ADD {index} {docId} {score} \n    [NOSAVE]\n    [LANGUAGE {language}] \n    FIELDS {field} {value} [{field} {value}...]\n\n\n\n\nDescription\n\n\nAdd a documet to the index.\n\n\nParameters:\n\n\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\n\n\n\n\ndocId\n: The document's id that will be returned from searches. \n  Note that the same docId cannot be added twice to the same index\n\n\n\n\n\n\nscore\n: The document's rank based on the user's ranking. This must be between 0.0 and 1.0. \n  If you don't have a score just set it to 1\n\n\n\n\n\n\nNOSAVE\n: If set to true, we will not save the actual document in the index and only index it.\n\n\n\n\n\n\nFIELDS\n: Following the FIELDS specifier, we are looking for pairs of  \n{field} {value}\n to be indexed.\n\n\n\n\n\n\nEach field will be scored based on the index spec given in FT.CREATE. \n  Passing fields that are not in the index spec will make them be stored as part of the document, or ignored if NOSAVE is set \n\n\n\n\nLANGUAGE language\n: If set, we use a stemmer for the supplied langauge during indexing. Defaults to English. \n  If an unsupported language is sent, the command returns an error. \n  The supported languages are:\n\n\n\n\n\n\n\"arabic\",  \"danish\",    \"dutch\",   \"english\",   \"finnish\",    \"french\",\n\"german\",  \"hungarian\", \"italian\", \"norwegian\", \"portuguese\", \"romanian\",\n\"russian\", \"spanish\",   \"swedish\", \"tamil\",     \"turkish\"\n\n\n\n\nComplexity\n\n\nO(n), where n is the number of tokens in the document\n\n\nReturns\n\n\nOK on success, or an error if something went wrong.\n\n\n\n\nFT.ADDHASH\n\n\nFormat\n\n\n FT.ADDHASH {index} {docId} {score} [LANGUAGE language]\n\n\n\n\nDescription\n\n\nAdd a documet to the index from an existing HASH key in Redis.\n\n\nParameters:\n\n\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\n\n\n\n\ndocId\n: The document's id. This has to be an existing HASH key in redis that will hold the fields \n    the index needs.\n\n\n\n\n\n\nscore\n: The document's rank based on the user's ranking. This must be between 0.0 and 1.0. \n  If you don't have a score just set it to 1\n\n\n\n\n\n\nLANGUAGE language\n: If set, we use a stemmer for the supplied langauge during indexing. Defaults to English. \n  If an unsupported language is sent, the command returns an error. \n  The supported languages are:\n\n\n\n\n\n\n\n\n\"arabic\",  \"danish\",    \"dutch\",   \"english\",   \"finnish\",    \"french\",\n\"german\",  \"hungarian\", \"italian\", \"norwegian\", \"portuguese\", \"romanian\",\n\"russian\", \"spanish\",   \"swedish\", \"tamil\",     \"turkish\"\n\n\n\n\nComplexity\n\n\nO(n), where n is the number of tokens in the document\n\n\nReturns\n\n\nOK on success, or an error if something went wrong.\n\n\n\n\nFT.INFO\n\n\nFormat\n\n\nFT.INFO {index} \n\n\n\n\nDescription\n\n\nReturn information and statistics on the index. Returned values include:\n\n\n\n\nNumber of documents.\n\n\nNumber of distinct terms.\n\n\nAverage bytes per record.\n\n\nSize and capacity of the index buffers.\n\n\n\n\nExample:\n\n\n127.0.0.1:6379\n ft.info wik{0}\n 1) index_name\n 2) wikipedia\n 3) fields\n 4) 1) 1) title\n       2) type\n       3) FULLTEXT\n       4) weight\n       5) \n1\n\n    2) 1) body\n       2) type\n       3) FULLTEXT\n       4) weight\n       5) \n1\n\n 5) num_docs\n 6) \n502694\n\n 7) num_terms\n 8) \n439158\n\n 9) num_records\n10) \n8098583\n\n11) inverted_sz_mb\n12) \n45.58\n13) inverted_cap_mb\n14) \n56.61\n15) inverted_cap_ovh\n16) \n0.19\n17) offset_vectors_sz_mb\n18) \n9.27\n19) skip_index_size_mb\n20) \n7.35\n21) score_index_size_mb\n22) \n30.8\n23) records_per_doc_avg\n24) \n16.1\n25) bytes_per_record_avg\n26) \n5.90\n27) offsets_per_term_avg\n28) \n1.20\n29) offset_bits_per_record_avg\n30) \n8.00\n\n\n\n\nParameters\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\n\n\nComplexity\n\n\nO(1)\n\n\nReturns\n\n\nArray Response. A nested array of keys and values.\n\n\n\n\nFT.SEARCH\n\n\nFormat\n\n\nFT.SEARCH {index} {query} [NOCONTENT] [VERBATIM] [NOSTOPWORDS] [WITHSCORES]\n  [FILTER {numeric_field} {min} {max}]\n  [GEOFILTER {geo_field} {lon} {lat} {raius} m|km|mi|ft]\n    [LANGUAGE language]\n    [EXPANDER expander]\n    [INFIELDS num field ... ]\n  [LIMIT offset num]\n\n\n\n\nDescription\n\n\nSearch the index with a textual query, returning either documents or just ids.\n\n\nParameters\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\nquery\n: the text query to search. If it's more than a single word, put it in quotes.\n  See below for documentation on query syntax. \n\n\nNOCONTENT\n: If it appears after the query, we only return the document ids and not \n  the content. This is useful if rediseach is only an index on an external document collection\n\n\nLIMIT first num\n: If the parameters appear after the query, we limit the results to \n  the offset and number of results given. The default is 0 10\n\n\nINFIELDS num field ...\n: If set, filter the results to ones appearing only in specific\n  fields of the document, like title or url. num is the number of specified field arguments\n\n\nFILTER numeric_field min max\n: If set, and numeric_field is defined as a numeric field in \n  FT.CREATE, we will limit results to those having numeric values ranging between min and max.\n  min and max follow ZRANGE syntax, and can be \n-inf\n, \n+inf\n and use \n(\n for exclusive ranges.\n\n\nGEOFILTER {geo_field} {lon} {lat} {raius} m|km|mi|ft\n: If set, we filter the results to a given radius \n  from lon and lat. Radius is given as a number and units. See \nGEORADIUS\n for more details. \n\n\nNOSTOPWORDS\n: If set, we do not filter stopwords from the query. \n\n\nWITHSCORES\n: If set, we also return the relative internal score of each document. this can be\n  used to merge results from multiple instances\n\n\nVERBATIM\n: if set, we do not try to use stemming for query expansion but search the query terms verbatim.\n\n\nLANGUAGE language\n: If set, we use a stemmer for the supplied langauge during search for query expansion. \n  Defaults to English. If an unsupported language is sent, the command returns an error. See FT.ADD for the list of languages.\n\n\nEXPANDER expander\n: If set, we will use a custom query expander instead of the stemmer. Currently has no affect.\n\n\n\n\nComplexity\n\n\nO(n) for single word queries (though for popular words we save a cache of the top 50 results).\n\n\nComplexity for complex queries changes, but in general it's proportional to the number of words and the number of intersection points between them.\n\n\nReturns\n\n\nArray reply,\n where the first element is the total number of results, and then pairs of document id, and a nested array of field/value. \n\n\nIf \nNOCONTENT\n was given, we return an array where the first element is the total number of results, and the rest of the members are document ids.\n\n\n\n\nFT.DEL\n\n\nFormat\n\n\nFT.DEL {index} {doc_id}\n\n\n\n\nDescription\n\n\nDelete a document from the index. Returns 1 if the document was in the index, or 0 if not. \n\n\nAfter deletion, the document can be re-added to the index. It will get a different internal id and will be a new document from the index's POV.\n\n\nNOTE\n: This does not actually delete the document from the index, just marks it as deleted. \nThus, deleting and re-inserting the same document over and over will inflate the index size with each re-insertion.\n\n\nParameters\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\ndoc_id\n: the id of the document to be deleted. It does not actually delete the HASH key in which the document is stored. Use DEL to do that manually if needed.\n\n\n\n\nComplexity\n\n\nO(1)\n\n\nReturns\n\n\nInteger Reply: 1 if the document was deleted, 0 if not.\n\n\n\n\nFT.DROP\n\n\nFormat\n\n\nFT.DROP {index}\n\n\n\n\nDescription\n\n\nDeletes all the keys associated with the index. \n\n\nIf no other data is on the redis instance, this is equivalent to FLUSHDB, apart from the fact\nthat the index specification is not deleted.\n\n\nParameters\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\n\n\nReturns\n\n\nStatus Reply: OK on success.\n\n\n\n\nFT.OPTIMIZE\n\n\nFormat\n\n\nFT.OPTIMIZE {index}\n\n\n\n\nDescription\n\n\nAfter the index is built (and doesn't need to be updated again withuot a complete rebuild)\nwe can optimize memory consumption by trimming all index buffers to their actual size.\n\n\nWarning 1\n: Do not run it if you intend to update your index afterward.\n\n\nWarning 2\n: This blocks redis for a long time. Do not run it on production instances\n\n\nParameters\n\n\n\n\nindex\n: The Fulltext index name. The index must be first created with FT.CREATE\n\n\n\n\nReturns:\n\n\nInteger Reply - the number of index entries optimized.\n\n\n\n\nFT.SUGGADD\n\n\nFormat\n\n\nFT.SUGADD {key} {string} {score} [INCR]\n\n\n\n\nDescription\n\n\nAdd a suggestion string to an auto-complete suggestion dictionary. This is disconnected from the\nindex definitions, and leaves creating and updating suggestino dictionaries to the user.\n\n\nParameters\n\n\n\n\nkey\n: the suggestion dictionary key.\n\n\nstring\n: the suggestion string we index\n\n\nscore\n: a floating point number of the suggestion string's weight\n\n\nINCR\n: if set, we increment the existing entry of the suggestion by the given score, instead of replacing the score. This is useful for updating the dictionary based on user queries in real time\n\n\n\n\nReturns:\n\n\nInteger Reply: the current size of the suggestion dictionary.\n\n\n\n\nFT.SUGGET\n\n\nFormat\n\n\nFT.SUGGET {key} {prefix} [FUZZY] [MAX num]\n\n\n\n\nDescription\n\n\nGet completion suggestions for a prefix\n\n\nParameters:\n\n\n\n\nkey\n: the suggestion dictionary key.\n\n\nprefix\n: the prefix to complete on\n\n\nFUZZY\n: if set,we do a fuzzy prefix search, including prefixes at levenshtein distance of 1 from the prefix sent\n\n\nMAX num\n: If set, we limit the results to a maximum of \nnum\n. (\nNote\n: The default is 5, and the number cannot be greater than 10).\n\n\nWITHSCORES\n: If set, we also return the score of each suggestion. this can be\n  used to merge results from multiple instances\n\n\n\n\nReturns:\n\n\nArray Reply: a list of the top suggestions matching the prefix, optionally with score after each entry\n\n\n\n\nFT.SUGDEL\n\n\nFormat\n\n\nFT.SUGDEL {key} {string}\n\n\n\n\nDescription\n\n\nDelete a string from a suggestion index. \n\n\nParameters\n\n\n\n\nkey\n: the suggestion dictionary key.\n\n\nstring\n: the string to delete\n\n\n\n\nReturns:\n\n\nInteger Reply: 1 if the string was found and deleted, 0 otherwise.\n\n\n\n\nFT.SUGLEN\n\n\nFormat\n\n\nFT.SUGLEN {key}\n\n\n\n\nDescription\n\n\nGet the size of an autoc-complete suggestion dictionary\n\n\nParameters\n\n\n\n\nkey\n: the suggestion dictionary key.\n\n\n\n\nReturns:\n\n\nInteger Reply: the current size of the suggestion dictionary.", 
            "title": "Commands"
        }, 
        {
            "location": "/Commands/#rediseach-full-command-documentation", 
            "text": "", 
            "title": "RediSeach Full Command Documentation"
        }, 
        {
            "location": "/Commands/#ftcreate", 
            "text": "", 
            "title": "FT.CREATE"
        }, 
        {
            "location": "/Commands/#format", 
            "text": "FT.CREATE {index} \n    [NOOFFSETS] [NOFIELDS] [NOSCOREIDX]\n    SCHEMA {field} [TEXT [WEIGHT {weight}] | NUMERIC | GEO] ...", 
            "title": "Format:"
        }, 
        {
            "location": "/Commands/#description", 
            "text": "Creates an index with the given spec. The index name will be used in all the key names\nso keep it short!", 
            "title": "Description:"
        }, 
        {
            "location": "/Commands/#parameters", 
            "text": "index : the index name to create. If it exists the old spec will be overwritten    NOOFFSETS : If set, we do not store term offsets for documents (saves memory, does not allow exact searches)    NOFIELDS : If set, we do not store field bits for each term. Saves memory, does not allow filtering by specific fields.    NOSCOREIDX : If set, we avoid saving the top results for single words. Saves a lot of memory, slows down searches for common single word queries.    SCHEMA {field} {options...} : After the SCHEMA keyword we define the index fields. \nThey can be numeric, textual or geographical. For textual fields we optionally specify a weight. The default weight is 1.0.", 
            "title": "Parameters:"
        }, 
        {
            "location": "/Commands/#complexity", 
            "text": "O(1)", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns", 
            "text": "OK or an error", 
            "title": "Returns:"
        }, 
        {
            "location": "/Commands/#ftadd", 
            "text": "", 
            "title": "FT.ADD"
        }, 
        {
            "location": "/Commands/#format_1", 
            "text": "FT.ADD {index} {docId} {score} \n    [NOSAVE]\n    [LANGUAGE {language}] \n    FIELDS {field} {value} [{field} {value}...]", 
            "title": "Format:"
        }, 
        {
            "location": "/Commands/#description_1", 
            "text": "Add a documet to the index.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_1", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE    docId : The document's id that will be returned from searches. \n  Note that the same docId cannot be added twice to the same index    score : The document's rank based on the user's ranking. This must be between 0.0 and 1.0. \n  If you don't have a score just set it to 1    NOSAVE : If set to true, we will not save the actual document in the index and only index it.    FIELDS : Following the FIELDS specifier, we are looking for pairs of   {field} {value}  to be indexed.    Each field will be scored based on the index spec given in FT.CREATE. \n  Passing fields that are not in the index spec will make them be stored as part of the document, or ignored if NOSAVE is set    LANGUAGE language : If set, we use a stemmer for the supplied langauge during indexing. Defaults to English. \n  If an unsupported language is sent, the command returns an error. \n  The supported languages are:    \"arabic\",  \"danish\",    \"dutch\",   \"english\",   \"finnish\",    \"french\",\n\"german\",  \"hungarian\", \"italian\", \"norwegian\", \"portuguese\", \"romanian\",\n\"russian\", \"spanish\",   \"swedish\", \"tamil\",     \"turkish\"", 
            "title": "Parameters:"
        }, 
        {
            "location": "/Commands/#complexity_1", 
            "text": "O(n), where n is the number of tokens in the document", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns_1", 
            "text": "OK on success, or an error if something went wrong.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftaddhash", 
            "text": "", 
            "title": "FT.ADDHASH"
        }, 
        {
            "location": "/Commands/#format_2", 
            "text": "FT.ADDHASH {index} {docId} {score} [LANGUAGE language]", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_2", 
            "text": "Add a documet to the index from an existing HASH key in Redis.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_2", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE    docId : The document's id. This has to be an existing HASH key in redis that will hold the fields \n    the index needs.    score : The document's rank based on the user's ranking. This must be between 0.0 and 1.0. \n  If you don't have a score just set it to 1    LANGUAGE language : If set, we use a stemmer for the supplied langauge during indexing. Defaults to English. \n  If an unsupported language is sent, the command returns an error. \n  The supported languages are:     \"arabic\",  \"danish\",    \"dutch\",   \"english\",   \"finnish\",    \"french\",\n\"german\",  \"hungarian\", \"italian\", \"norwegian\", \"portuguese\", \"romanian\",\n\"russian\", \"spanish\",   \"swedish\", \"tamil\",     \"turkish\"", 
            "title": "Parameters:"
        }, 
        {
            "location": "/Commands/#complexity_2", 
            "text": "O(n), where n is the number of tokens in the document", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns_2", 
            "text": "OK on success, or an error if something went wrong.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftinfo", 
            "text": "", 
            "title": "FT.INFO"
        }, 
        {
            "location": "/Commands/#format_3", 
            "text": "FT.INFO {index}", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_3", 
            "text": "Return information and statistics on the index. Returned values include:   Number of documents.  Number of distinct terms.  Average bytes per record.  Size and capacity of the index buffers.   Example:  127.0.0.1:6379  ft.info wik{0}\n 1) index_name\n 2) wikipedia\n 3) fields\n 4) 1) 1) title\n       2) type\n       3) FULLTEXT\n       4) weight\n       5)  1 \n    2) 1) body\n       2) type\n       3) FULLTEXT\n       4) weight\n       5)  1 \n 5) num_docs\n 6)  502694 \n 7) num_terms\n 8)  439158 \n 9) num_records\n10)  8098583 \n11) inverted_sz_mb\n12)  45.58\n13) inverted_cap_mb\n14)  56.61\n15) inverted_cap_ovh\n16)  0.19\n17) offset_vectors_sz_mb\n18)  9.27\n19) skip_index_size_mb\n20)  7.35\n21) score_index_size_mb\n22)  30.8\n23) records_per_doc_avg\n24)  16.1\n25) bytes_per_record_avg\n26)  5.90\n27) offsets_per_term_avg\n28)  1.20\n29) offset_bits_per_record_avg\n30)  8.00", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_3", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#complexity_3", 
            "text": "O(1)", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns_3", 
            "text": "Array Response. A nested array of keys and values.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftsearch", 
            "text": "", 
            "title": "FT.SEARCH"
        }, 
        {
            "location": "/Commands/#format_4", 
            "text": "FT.SEARCH {index} {query} [NOCONTENT] [VERBATIM] [NOSTOPWORDS] [WITHSCORES]\n  [FILTER {numeric_field} {min} {max}]\n  [GEOFILTER {geo_field} {lon} {lat} {raius} m|km|mi|ft]\n    [LANGUAGE language]\n    [EXPANDER expander]\n    [INFIELDS num field ... ]\n  [LIMIT offset num]", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_4", 
            "text": "Search the index with a textual query, returning either documents or just ids.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_4", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE  query : the text query to search. If it's more than a single word, put it in quotes.\n  See below for documentation on query syntax.   NOCONTENT : If it appears after the query, we only return the document ids and not \n  the content. This is useful if rediseach is only an index on an external document collection  LIMIT first num : If the parameters appear after the query, we limit the results to \n  the offset and number of results given. The default is 0 10  INFIELDS num field ... : If set, filter the results to ones appearing only in specific\n  fields of the document, like title or url. num is the number of specified field arguments  FILTER numeric_field min max : If set, and numeric_field is defined as a numeric field in \n  FT.CREATE, we will limit results to those having numeric values ranging between min and max.\n  min and max follow ZRANGE syntax, and can be  -inf ,  +inf  and use  (  for exclusive ranges.  GEOFILTER {geo_field} {lon} {lat} {raius} m|km|mi|ft : If set, we filter the results to a given radius \n  from lon and lat. Radius is given as a number and units. See  GEORADIUS  for more details.   NOSTOPWORDS : If set, we do not filter stopwords from the query.   WITHSCORES : If set, we also return the relative internal score of each document. this can be\n  used to merge results from multiple instances  VERBATIM : if set, we do not try to use stemming for query expansion but search the query terms verbatim.  LANGUAGE language : If set, we use a stemmer for the supplied langauge during search for query expansion. \n  Defaults to English. If an unsupported language is sent, the command returns an error. See FT.ADD for the list of languages.  EXPANDER expander : If set, we will use a custom query expander instead of the stemmer. Currently has no affect.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#complexity_4", 
            "text": "O(n) for single word queries (though for popular words we save a cache of the top 50 results).  Complexity for complex queries changes, but in general it's proportional to the number of words and the number of intersection points between them.", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns_4", 
            "text": "Array reply,  where the first element is the total number of results, and then pairs of document id, and a nested array of field/value.   If  NOCONTENT  was given, we return an array where the first element is the total number of results, and the rest of the members are document ids.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftdel", 
            "text": "", 
            "title": "FT.DEL"
        }, 
        {
            "location": "/Commands/#format_5", 
            "text": "FT.DEL {index} {doc_id}", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_5", 
            "text": "Delete a document from the index. Returns 1 if the document was in the index, or 0 if not.   After deletion, the document can be re-added to the index. It will get a different internal id and will be a new document from the index's POV.  NOTE : This does not actually delete the document from the index, just marks it as deleted. \nThus, deleting and re-inserting the same document over and over will inflate the index size with each re-insertion.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_5", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE  doc_id : the id of the document to be deleted. It does not actually delete the HASH key in which the document is stored. Use DEL to do that manually if needed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#complexity_5", 
            "text": "O(1)", 
            "title": "Complexity"
        }, 
        {
            "location": "/Commands/#returns_5", 
            "text": "Integer Reply: 1 if the document was deleted, 0 if not.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftdrop", 
            "text": "", 
            "title": "FT.DROP"
        }, 
        {
            "location": "/Commands/#format_6", 
            "text": "FT.DROP {index}", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_6", 
            "text": "Deletes all the keys associated with the index.   If no other data is on the redis instance, this is equivalent to FLUSHDB, apart from the fact\nthat the index specification is not deleted.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_6", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#returns_6", 
            "text": "Status Reply: OK on success.", 
            "title": "Returns"
        }, 
        {
            "location": "/Commands/#ftoptimize", 
            "text": "Format  FT.OPTIMIZE {index}  Description  After the index is built (and doesn't need to be updated again withuot a complete rebuild)\nwe can optimize memory consumption by trimming all index buffers to their actual size.  Warning 1 : Do not run it if you intend to update your index afterward.  Warning 2 : This blocks redis for a long time. Do not run it on production instances", 
            "title": "FT.OPTIMIZE"
        }, 
        {
            "location": "/Commands/#parameters_7", 
            "text": "index : The Fulltext index name. The index must be first created with FT.CREATE", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#returns_7", 
            "text": "Integer Reply - the number of index entries optimized.", 
            "title": "Returns:"
        }, 
        {
            "location": "/Commands/#ftsuggadd", 
            "text": "", 
            "title": "FT.SUGGADD"
        }, 
        {
            "location": "/Commands/#format_7", 
            "text": "FT.SUGADD {key} {string} {score} [INCR]", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_7", 
            "text": "Add a suggestion string to an auto-complete suggestion dictionary. This is disconnected from the\nindex definitions, and leaves creating and updating suggestino dictionaries to the user.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_8", 
            "text": "key : the suggestion dictionary key.  string : the suggestion string we index  score : a floating point number of the suggestion string's weight  INCR : if set, we increment the existing entry of the suggestion by the given score, instead of replacing the score. This is useful for updating the dictionary based on user queries in real time", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#returns_8", 
            "text": "Integer Reply: the current size of the suggestion dictionary.", 
            "title": "Returns:"
        }, 
        {
            "location": "/Commands/#ftsugget", 
            "text": "", 
            "title": "FT.SUGGET"
        }, 
        {
            "location": "/Commands/#format_8", 
            "text": "FT.SUGGET {key} {prefix} [FUZZY] [MAX num]", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_8", 
            "text": "Get completion suggestions for a prefix", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_9", 
            "text": "key : the suggestion dictionary key.  prefix : the prefix to complete on  FUZZY : if set,we do a fuzzy prefix search, including prefixes at levenshtein distance of 1 from the prefix sent  MAX num : If set, we limit the results to a maximum of  num . ( Note : The default is 5, and the number cannot be greater than 10).  WITHSCORES : If set, we also return the score of each suggestion. this can be\n  used to merge results from multiple instances", 
            "title": "Parameters:"
        }, 
        {
            "location": "/Commands/#returns_9", 
            "text": "Array Reply: a list of the top suggestions matching the prefix, optionally with score after each entry", 
            "title": "Returns:"
        }, 
        {
            "location": "/Commands/#ftsugdel", 
            "text": "", 
            "title": "FT.SUGDEL"
        }, 
        {
            "location": "/Commands/#format_9", 
            "text": "FT.SUGDEL {key} {string}", 
            "title": "Format"
        }, 
        {
            "location": "/Commands/#description_9", 
            "text": "Delete a string from a suggestion index.", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_10", 
            "text": "key : the suggestion dictionary key.  string : the string to delete", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#returns_10", 
            "text": "Integer Reply: 1 if the string was found and deleted, 0 otherwise.", 
            "title": "Returns:"
        }, 
        {
            "location": "/Commands/#ftsuglen", 
            "text": "Format  FT.SUGLEN {key}", 
            "title": "FT.SUGLEN"
        }, 
        {
            "location": "/Commands/#description_10", 
            "text": "Get the size of an autoc-complete suggestion dictionary", 
            "title": "Description"
        }, 
        {
            "location": "/Commands/#parameters_11", 
            "text": "key : the suggestion dictionary key.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Commands/#returns_11", 
            "text": "Integer Reply: the current size of the suggestion dictionary.", 
            "title": "Returns:"
        }, 
        {
            "location": "/Query_Syntax/", 
            "text": "Search Query Syntax:\n\n\nWe support a simple syntax for complex queries with the following rules:\n\n\n\n\nMulti-word phrases simply a list of tokens, e.g. \nfoo bar baz\n, and imply intersection (AND) of the terms.\n\n\nExact phrases are wrapped in quotes, e.g \n\"hello world\"\n.\n\n\nOR Unions (i.e \nword1 OR word2\n), are expressed with a pipe (\n|\n), e.g. \nhello|hallo|shalom|hola\n.\n\n\nAn expression in a query can be wrapped in parentheses to resolve disambiguity, e.g. \n(hello|hella) (world|werld)\n.\n\n\nCombinations of the above can be used together, e.g \nhello (world|foo) \"bar baz\" bbbb\n\n\n\n\nA few examples\n\n\n\n\n\n\nSimple phrase query - hello AND world\n\n\nhello world\n\n\n\n\n\n\n\nExact phrase query - \nhello\n FOLLOWED BY \nworld\n\n\n\"hello world\"\n\n\n\n\n\n\n\nUnion: documents containing either \nhello\n OR \nworld\n\n\nhello|world\n\n\n\n\n\n\n\nIntersection of unions\n\n\n(hello|halo) (world|werld)\n\n\n\n\n\n\n\nUnion inside phrase\n\n\n(barack|barrack) obama\n\n\n\n\n\n\n\nTechnical Note\n\n\nThe query parser is built using the Lemon Parser Generator. You can see the grammar definition \nat the git repo.", 
            "title": "Query Syntax"
        }, 
        {
            "location": "/Query_Syntax/#search-query-syntax", 
            "text": "We support a simple syntax for complex queries with the following rules:   Multi-word phrases simply a list of tokens, e.g.  foo bar baz , and imply intersection (AND) of the terms.  Exact phrases are wrapped in quotes, e.g  \"hello world\" .  OR Unions (i.e  word1 OR word2 ), are expressed with a pipe ( | ), e.g.  hello|hallo|shalom|hola .  An expression in a query can be wrapped in parentheses to resolve disambiguity, e.g.  (hello|hella) (world|werld) .  Combinations of the above can be used together, e.g  hello (world|foo) \"bar baz\" bbbb", 
            "title": "Search Query Syntax:"
        }, 
        {
            "location": "/Query_Syntax/#a-few-examples", 
            "text": "Simple phrase query - hello AND world  hello world    Exact phrase query -  hello  FOLLOWED BY  world  \"hello world\"    Union: documents containing either  hello  OR  world  hello|world    Intersection of unions  (hello|halo) (world|werld)    Union inside phrase  (barack|barrack) obama", 
            "title": "A few examples"
        }, 
        {
            "location": "/Query_Syntax/#technical-note", 
            "text": "The query parser is built using the Lemon Parser Generator. You can see the grammar definition  at the git repo.", 
            "title": "Technical Note"
        }, 
        {
            "location": "/Stemming/", 
            "text": "Stemming Support\n\n\nRediSearch supports stemming - that is adding the base form of a word to the index. This allows \nthe query for \"going\" to also return results for \"go\" and \"gone\", for example. \n\n\nThe current stemming support is based on the Snowball stemmer library, which supports most European\nlanguages, as well as Arabic and other. We hope to include more languages soon (if you need a specicif\nlangauge support, please open an issue). \n\n\nFor further details see the \nSnowball Stemmer website\n.\n\n\nSupported languages:\n\n\nThe following languages are supported, and can be passed to the engine \nwhen indexing or querying, with lowercase letters:\n\n\n\n\narabic\n\n\ndanish\n\n\ndutch\n\n\nenglish\n\n\nfinnish\n\n\nfrench\n\n\ngerman\n\n\nhungarian\n\n\nitalian\n\n\nnorwegian\n\n\nportuguese\n\n\nromanian\n\n\nrussian\n\n\nspanish\n\n\nswedish\n\n\ntamil\n\n\nturkish", 
            "title": "Stemming Support"
        }, 
        {
            "location": "/Stemming/#stemming-support", 
            "text": "RediSearch supports stemming - that is adding the base form of a word to the index. This allows \nthe query for \"going\" to also return results for \"go\" and \"gone\", for example.   The current stemming support is based on the Snowball stemmer library, which supports most European\nlanguages, as well as Arabic and other. We hope to include more languages soon (if you need a specicif\nlangauge support, please open an issue).   For further details see the  Snowball Stemmer website .", 
            "title": "Stemming Support"
        }, 
        {
            "location": "/Stemming/#supported-languages", 
            "text": "The following languages are supported, and can be passed to the engine \nwhen indexing or querying, with lowercase letters:   arabic  danish  dutch  english  finnish  french  german  hungarian  italian  norwegian  portuguese  romanian  russian  spanish  swedish  tamil  turkish", 
            "title": "Supported languages:"
        }, 
        {
            "location": "/python_client/", 
            "text": "Package redisearch Documentation\n\n\nOverview\n\n\nredisearch-py\n is a python search engine library that utilizes the RediSearch Redis Module API.\n\n\nIt is the \"official\" client of redisearch, and should be regarded as its canonical client implementation.\n\n\nThe source code can be found at \nhttp://github.com/RedisLabs/redisearch-py\n\n\nExample: Using the Python Client\n\n\n\nfrom redisearch import Client, TextField, NumericField\n\n# Creating a client with a given index name\nclient = Client('myIndex')\n\n# Creating the index definition and schema\nclient.create_index([TextField('title', weight=5.0), TextField('body')])\n\n# Indexing a document\nclient.add_document('doc1', title = 'RediSearch', body = 'Redisearch impements a search engine on top of redis')\n\n# Searching\nres = client.search(\nsearch engine\n)\n\n# the result has the total number of results, and a list of documents\nprint res.total # \n1\n\nprint res.docs[0].title \n\n\n\n\n\nExample: Using the Auto Completer Client:\n\n\n\n# Using the auto-completer\nac = AutoCompleter('ac')\n\n# Adding some terms\nac.add_suggestions(Suggestion('foo', 5.0), Suggestion('bar', 1.0))\n\n# Getting suggestions\nsuggs = ac.get_suggestions('goo') # returns nothing\n\nsuggs = ac.get_suggestions('goo', fuzzy = True) # returns ['foo']\n\n\n\n\n\nInstalling\n\n\n\n\n\n\nInstall redis 4.0 RC2 or above\n\n\n\n\n\n\nInstall RediSearch\n\n\n\n\n\n\nInstall the python client\n\n\n\n\n\n\n$ pip install redisearch\n\n\n\n\nClass AutoCompleter\n\n\nA client to RediSearch's AutoCompleter API\n\n\nIt provides prefix searches with optionally fuzzy matching of prefixes    \n\n\n__init__\n\n\n\ndef __init__(self, key, host='localhost', port=6379, conn=None)\n\n\n\n\n\nCreate a new AutoCompleter client for the given key, and optional host and port\n\n\nIf conn is not None, we employ an already existing redis connection\n\n\nadd_suggestions\n\n\n\ndef add_suggestions(self, *suggestions, **kwargs)\n\n\n\n\n\nAdd suggestion terms to the AutoCompleter engine. Each suggestion has a score and string.\n\n\nIf kwargs['increment'] is true and the terms are already in the server's dictionary, we increment their scores \n\n\ndelete\n\n\n\ndef delete(self, string)\n\n\n\n\n\nDelete a string from the AutoCompleter index.\nReturns 1 if the string was found and deleted, 0 otherwise\n\n\nget_suggestions\n\n\n\ndef get_suggestions(self, prefix, fuzzy=False, num=10, with_scores=False)\n\n\n\n\n\nGet a list of suggestions from the AutoCompleter, for a given prefix\n\n\nParameters:\n\n\n\n\nprefix\n: the prefix we are searching. \nMust be valid ascii or utf-8\n\n\nfuzzy\n: If set to true, the prefix search is done in fuzzy mode. \n    \nNOTE\n: Running fuzzy searches on short (\n3 letters) prefixes can be very slow, and even scan the entire index.\n\n\nwith_scores\n: if set to true, we also return the (refactored) score of each suggestion. \n  This is normally not needed, and is NOT the original score inserted into the index\n\n\nnum\n: The maximum number of results we return. Note that we might return less. The algorithm trims irrelevant suggestions.\n\n\n\n\nReturns a list of Suggestion objects. If with_scores was False, the score of all suggestions is 1.\n\n\nlen\n\n\n\ndef len(self)\n\n\n\n\n\nReturn the number of entries in the AutoCompleter index\n\n\nClass Client\n\n\nA client for the RediSearch module. \nIt abstracts the API of the module and lets you just use the engine \n\n\n__init__\n\n\n\ndef __init__(self, index_name, host='localhost', port=6379, conn=None)\n\n\n\n\n\nCreate a new Client for the given index_name, and optional host and port\n\n\nIf conn is not None, we employ an already existing redis connection\n\n\nadd_document\n\n\n\ndef add_document(self, doc_id, nosave=False, score=1.0, **fields)\n\n\n\n\n\nAdd a single document to the index.\n\n\nParameters\n\n\n\n\ndoc_id\n: the id of the saved document.\n\n\nnosave\n: if set to true, we just index the document, and don't save a copy of it. This means that searches will just return ids.\n\n\nscore\n: the document ranking, between 0.0 and 1.0 \n\n\nfields\n kwargs dictionary of the document fields to be saved and/or indexed. \n             NOTE: Geo points shoule be encoded as strings of \"lon,lat\"\n\n\n\n\nbatch_indexer\n\n\n\ndef batch_indexer(self, chunk_size=100)\n\n\n\n\n\nCreate a new batch indexer from the client with a given chunk size\n\n\ncreate_index\n\n\n\ndef create_index(self, fields, no_term_offsets=False, no_field_flags=False, no_score_indexes=False)\n\n\n\n\n\nCreate the search index. Creating an existing index juts updates its properties\n\n\nParameters:\n\n\n\n\nfields\n: a list of TextField or NumericField objects\n\n\nno_term_offsets\n: If true, we will not save term offsets in the index\n\n\nno_field_flags\n: If true, we will not save field flags that allow searching in specific fields\n\n\nno_score_indexes\n: If true, we will not save optimized top score indexes for single word queries\n\n\n\n\ndrop_index\n\n\n\ndef drop_index(self)\n\n\n\n\n\nDrop the index if it exists\n\n\ninfo\n\n\n\ndef info(self)\n\n\n\n\n\nGet info an stats about the the current index, including the number of documents, memory consumption, etc\n\n\nload_document\n\n\n\ndef load_document(self, id)\n\n\n\n\n\nLoad a single document by id\n\n\nsearch\n\n\n\ndef search(self, query, snippet_sizes=None)\n\n\n\n\n\nSearch the index for a given query, and return a result of documents\n\n\nParameters\n\n\n\n\nquery\n: the search query. Either a text for simple queries with default parameters, or a Query object for complex queries.\n             See RediSearch's documentation on query format\n\n\nsnippet_sizes\n: A dictionary of {field: snippet_size} used to trim and format the result. e.g.e {'body': 500}\n\n\n\n\nClass BatchIndexer\n\n\nA batch indexer allows you to automatically batch \ndocument indexeing in pipelines, flushing it every N documents. \n\n\n__init__\n\n\n\ndef __init__(self, client, chunk_size=1000)\n\n\n\n\n\nadd_document\n\n\n\ndef add_document(self, doc_id, nosave=False, score=1.0, **fields)\n\n\n\n\n\nAdd a document to the batch query\n\n\ncommit\n\n\n\ndef commit(self)\n\n\n\n\n\nManually commit and flush the batch indexing query\n\n\nClass Document\n\n\nRepresents a single document in a result set \n\n\n__init__\n\n\n\ndef __init__(self, id, **fields)\n\n\n\n\n\nsnippetize\n\n\n\ndef snippetize(self, field, size=500, bold_tokens=())\n\n\n\n\n\nCreate a shortened snippet from the document's content \n:param size: the szie of the snippet in characters. It might be a bit longer or shorter\n:param boldTokens: a list of tokens we want to make bold (basically the query terms)\n\n\nClass GeoField\n\n\nGeoField is used to define a geo-indexing field in a schema defintion\n\n\n__init__\n\n\n\ndef __init__(self, name)\n\n\n\n\n\nredis_args\n\n\n\ndef redis_args(self)\n\n\n\n\n\nClass GeoFilter\n\n\nNone\n\n\n__init__\n\n\n\ndef __init__(self, field, lon, lat, radius, unit='km')\n\n\n\n\n\nClass NumericField\n\n\nNumericField is used to define a numeric field in a schema defintion\n\n\n__init__\n\n\n\ndef __init__(self, name)\n\n\n\n\n\nredis_args\n\n\n\ndef redis_args(self)\n\n\n\n\n\nClass NumericFilter\n\n\nNone\n\n\n__init__\n\n\n\ndef __init__(self, field, minval, maxval, minExclusive=False, maxExclusive=False)\n\n\n\n\n\nClass Query\n\n\nQuery is used to build complex queries that have more parameters than just the query string.\nThe query string is set in the constructor, and other options have setter functions.\n\n\nThe setter functions return the query object, so they can be chained, \ni.e. \nQuery(\"foo\").verbatim().filter(...)\n etc.\n\n\n__init__\n\n\n\ndef __init__(self, query_string)\n\n\n\n\n\nCreate a new query object. \n\n\nThe query string is set in the constructor, and other options have setter functions.\n\n\nadd_filter\n\n\n\ndef add_filter(self, flt)\n\n\n\n\n\nAdd a numeric or geo filter to the query. \n\nCurrently only one of each filter is supported by the engine\n\n\n\n\nflt\n: A NumericFilter or GeoFilter object, used on a corresponding field\n\n\n\n\nget_args\n\n\n\ndef get_args(self)\n\n\n\n\n\nFormat the redis arguments for this query and return them\n\n\nlimit_fields\n\n\n\ndef limit_fields(self, *fields)\n\n\n\n\n\nLimit the search to specific TEXT fields only\n\n\n\n\nfields\n: A list of strings, case sensitive field names from the defined schema\n\n\n\n\nno_content\n\n\n\ndef no_content(self)\n\n\n\n\n\nSet the query to only return ids and not the document content\n\n\nno_stopwords\n\n\n\ndef no_stopwords(self)\n\n\n\n\n\nPrevent the query from being filtered for stopwords. \nOnly useful in very big queries that you are certain contain no stopwords.\n\n\npaging\n\n\n\ndef paging(self, offset, num)\n\n\n\n\n\nSet the paging for the query (defaults to 0..10).\n\n\n\n\noffset\n: Paging offset for the results. Defaults to 0\n\n\nnum\n: How many results do we want\n\n\n\n\nquery_string\n\n\n\ndef query_string(self)\n\n\n\n\n\nReturn the query string of this query only\n\n\nverbatim\n\n\n\ndef verbatim(self)\n\n\n\n\n\nSet the query to be verbatim, i.e. use no query expansion or stemming\n\n\nClass Result\n\n\nRepresents the result of a search query, and has an array of Document objects\n\n\n__init__\n\n\n\ndef __init__(self, res, hascontent, query_text, duration=0, snippets=None)\n\n\n\n\n\n\n\nsnippets\n: An optional dictionary of the form {field: snippet_size} for snippet formatting\n\n\n\n\nClass Suggestion\n\n\nRepresents a single suggestion being sent or returned from the auto complete server\n\n\n__init__\n\n\n\ndef __init__(self, string, score=1.0)\n\n\n\n\n\nClass TextField\n\n\nTextField is used to define a text field in a schema definition\n\n\n__init__\n\n\n\ndef __init__(self, name, weight=1.0)\n\n\n\n\n\nredis_args\n\n\n\ndef redis_args(self)", 
            "title": "Python API"
        }, 
        {
            "location": "/python_client/#package-redisearch-documentation", 
            "text": "", 
            "title": "Package redisearch Documentation"
        }, 
        {
            "location": "/python_client/#overview", 
            "text": "redisearch-py  is a python search engine library that utilizes the RediSearch Redis Module API.  It is the \"official\" client of redisearch, and should be regarded as its canonical client implementation.  The source code can be found at  http://github.com/RedisLabs/redisearch-py", 
            "title": "Overview"
        }, 
        {
            "location": "/python_client/#example-using-the-python-client", 
            "text": "from redisearch import Client, TextField, NumericField\n\n# Creating a client with a given index name\nclient = Client('myIndex')\n\n# Creating the index definition and schema\nclient.create_index([TextField('title', weight=5.0), TextField('body')])\n\n# Indexing a document\nclient.add_document('doc1', title = 'RediSearch', body = 'Redisearch impements a search engine on top of redis')\n\n# Searching\nres = client.search( search engine )\n\n# the result has the total number of results, and a list of documents\nprint res.total #  1 \nprint res.docs[0].title", 
            "title": "Example: Using the Python Client"
        }, 
        {
            "location": "/python_client/#example-using-the-auto-completer-client", 
            "text": "# Using the auto-completer\nac = AutoCompleter('ac')\n\n# Adding some terms\nac.add_suggestions(Suggestion('foo', 5.0), Suggestion('bar', 1.0))\n\n# Getting suggestions\nsuggs = ac.get_suggestions('goo') # returns nothing\n\nsuggs = ac.get_suggestions('goo', fuzzy = True) # returns ['foo']", 
            "title": "Example: Using the Auto Completer Client:"
        }, 
        {
            "location": "/python_client/#installing", 
            "text": "Install redis 4.0 RC2 or above    Install RediSearch    Install the python client    $ pip install redisearch", 
            "title": "Installing"
        }, 
        {
            "location": "/python_client/#class-autocompleter", 
            "text": "A client to RediSearch's AutoCompleter API  It provides prefix searches with optionally fuzzy matching of prefixes", 
            "title": "Class AutoCompleter"
        }, 
        {
            "location": "/python_client/#9595init9595", 
            "text": "def __init__(self, key, host='localhost', port=6379, conn=None)  Create a new AutoCompleter client for the given key, and optional host and port  If conn is not None, we employ an already existing redis connection", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#add95suggestions", 
            "text": "def add_suggestions(self, *suggestions, **kwargs)  Add suggestion terms to the AutoCompleter engine. Each suggestion has a score and string.  If kwargs['increment'] is true and the terms are already in the server's dictionary, we increment their scores", 
            "title": "add_suggestions"
        }, 
        {
            "location": "/python_client/#delete", 
            "text": "def delete(self, string)  Delete a string from the AutoCompleter index.\nReturns 1 if the string was found and deleted, 0 otherwise", 
            "title": "delete"
        }, 
        {
            "location": "/python_client/#get95suggestions", 
            "text": "def get_suggestions(self, prefix, fuzzy=False, num=10, with_scores=False)  Get a list of suggestions from the AutoCompleter, for a given prefix", 
            "title": "get_suggestions"
        }, 
        {
            "location": "/python_client/#parameters", 
            "text": "prefix : the prefix we are searching.  Must be valid ascii or utf-8  fuzzy : If set to true, the prefix search is done in fuzzy mode. \n     NOTE : Running fuzzy searches on short ( 3 letters) prefixes can be very slow, and even scan the entire index.  with_scores : if set to true, we also return the (refactored) score of each suggestion. \n  This is normally not needed, and is NOT the original score inserted into the index  num : The maximum number of results we return. Note that we might return less. The algorithm trims irrelevant suggestions.   Returns a list of Suggestion objects. If with_scores was False, the score of all suggestions is 1.", 
            "title": "Parameters:"
        }, 
        {
            "location": "/python_client/#len", 
            "text": "def len(self)  Return the number of entries in the AutoCompleter index", 
            "title": "len"
        }, 
        {
            "location": "/python_client/#class-client", 
            "text": "A client for the RediSearch module. \nIt abstracts the API of the module and lets you just use the engine", 
            "title": "Class Client"
        }, 
        {
            "location": "/python_client/#9595init9595_1", 
            "text": "def __init__(self, index_name, host='localhost', port=6379, conn=None)  Create a new Client for the given index_name, and optional host and port  If conn is not None, we employ an already existing redis connection", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#add95document", 
            "text": "def add_document(self, doc_id, nosave=False, score=1.0, **fields)  Add a single document to the index.", 
            "title": "add_document"
        }, 
        {
            "location": "/python_client/#parameters_1", 
            "text": "doc_id : the id of the saved document.  nosave : if set to true, we just index the document, and don't save a copy of it. This means that searches will just return ids.  score : the document ranking, between 0.0 and 1.0   fields  kwargs dictionary of the document fields to be saved and/or indexed. \n             NOTE: Geo points shoule be encoded as strings of \"lon,lat\"", 
            "title": "Parameters"
        }, 
        {
            "location": "/python_client/#batch95indexer", 
            "text": "def batch_indexer(self, chunk_size=100)  Create a new batch indexer from the client with a given chunk size", 
            "title": "batch_indexer"
        }, 
        {
            "location": "/python_client/#create95index", 
            "text": "def create_index(self, fields, no_term_offsets=False, no_field_flags=False, no_score_indexes=False)  Create the search index. Creating an existing index juts updates its properties", 
            "title": "create_index"
        }, 
        {
            "location": "/python_client/#parameters_2", 
            "text": "fields : a list of TextField or NumericField objects  no_term_offsets : If true, we will not save term offsets in the index  no_field_flags : If true, we will not save field flags that allow searching in specific fields  no_score_indexes : If true, we will not save optimized top score indexes for single word queries", 
            "title": "Parameters:"
        }, 
        {
            "location": "/python_client/#drop95index", 
            "text": "def drop_index(self)  Drop the index if it exists", 
            "title": "drop_index"
        }, 
        {
            "location": "/python_client/#info", 
            "text": "def info(self)  Get info an stats about the the current index, including the number of documents, memory consumption, etc", 
            "title": "info"
        }, 
        {
            "location": "/python_client/#load95document", 
            "text": "def load_document(self, id)  Load a single document by id", 
            "title": "load_document"
        }, 
        {
            "location": "/python_client/#search", 
            "text": "def search(self, query, snippet_sizes=None)  Search the index for a given query, and return a result of documents", 
            "title": "search"
        }, 
        {
            "location": "/python_client/#parameters_3", 
            "text": "query : the search query. Either a text for simple queries with default parameters, or a Query object for complex queries.\n             See RediSearch's documentation on query format  snippet_sizes : A dictionary of {field: snippet_size} used to trim and format the result. e.g.e {'body': 500}", 
            "title": "Parameters"
        }, 
        {
            "location": "/python_client/#class-batchindexer", 
            "text": "A batch indexer allows you to automatically batch \ndocument indexeing in pipelines, flushing it every N documents.", 
            "title": "Class BatchIndexer"
        }, 
        {
            "location": "/python_client/#9595init9595_2", 
            "text": "def __init__(self, client, chunk_size=1000)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#add95document_1", 
            "text": "def add_document(self, doc_id, nosave=False, score=1.0, **fields)  Add a document to the batch query", 
            "title": "add_document"
        }, 
        {
            "location": "/python_client/#commit", 
            "text": "def commit(self)  Manually commit and flush the batch indexing query", 
            "title": "commit"
        }, 
        {
            "location": "/python_client/#class-document", 
            "text": "Represents a single document in a result set", 
            "title": "Class Document"
        }, 
        {
            "location": "/python_client/#9595init9595_3", 
            "text": "def __init__(self, id, **fields)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#snippetize", 
            "text": "def snippetize(self, field, size=500, bold_tokens=())  Create a shortened snippet from the document's content \n:param size: the szie of the snippet in characters. It might be a bit longer or shorter\n:param boldTokens: a list of tokens we want to make bold (basically the query terms)", 
            "title": "snippetize"
        }, 
        {
            "location": "/python_client/#class-geofield", 
            "text": "GeoField is used to define a geo-indexing field in a schema defintion", 
            "title": "Class GeoField"
        }, 
        {
            "location": "/python_client/#9595init9595_4", 
            "text": "def __init__(self, name)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#redis95args", 
            "text": "def redis_args(self)", 
            "title": "redis_args"
        }, 
        {
            "location": "/python_client/#class-geofilter", 
            "text": "None", 
            "title": "Class GeoFilter"
        }, 
        {
            "location": "/python_client/#9595init9595_5", 
            "text": "def __init__(self, field, lon, lat, radius, unit='km')", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#class-numericfield", 
            "text": "NumericField is used to define a numeric field in a schema defintion", 
            "title": "Class NumericField"
        }, 
        {
            "location": "/python_client/#9595init9595_6", 
            "text": "def __init__(self, name)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#redis95args_1", 
            "text": "def redis_args(self)", 
            "title": "redis_args"
        }, 
        {
            "location": "/python_client/#class-numericfilter", 
            "text": "None", 
            "title": "Class NumericFilter"
        }, 
        {
            "location": "/python_client/#9595init9595_7", 
            "text": "def __init__(self, field, minval, maxval, minExclusive=False, maxExclusive=False)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#class-query", 
            "text": "Query is used to build complex queries that have more parameters than just the query string.\nThe query string is set in the constructor, and other options have setter functions.  The setter functions return the query object, so they can be chained, \ni.e.  Query(\"foo\").verbatim().filter(...)  etc.", 
            "title": "Class Query"
        }, 
        {
            "location": "/python_client/#9595init9595_8", 
            "text": "def __init__(self, query_string)  Create a new query object.   The query string is set in the constructor, and other options have setter functions.", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#add95filter", 
            "text": "def add_filter(self, flt)  Add a numeric or geo filter to the query.  Currently only one of each filter is supported by the engine   flt : A NumericFilter or GeoFilter object, used on a corresponding field", 
            "title": "add_filter"
        }, 
        {
            "location": "/python_client/#get95args", 
            "text": "def get_args(self)  Format the redis arguments for this query and return them", 
            "title": "get_args"
        }, 
        {
            "location": "/python_client/#limit95fields", 
            "text": "def limit_fields(self, *fields)  Limit the search to specific TEXT fields only   fields : A list of strings, case sensitive field names from the defined schema", 
            "title": "limit_fields"
        }, 
        {
            "location": "/python_client/#no95content", 
            "text": "def no_content(self)  Set the query to only return ids and not the document content", 
            "title": "no_content"
        }, 
        {
            "location": "/python_client/#no95stopwords", 
            "text": "def no_stopwords(self)  Prevent the query from being filtered for stopwords. \nOnly useful in very big queries that you are certain contain no stopwords.", 
            "title": "no_stopwords"
        }, 
        {
            "location": "/python_client/#paging", 
            "text": "def paging(self, offset, num)  Set the paging for the query (defaults to 0..10).   offset : Paging offset for the results. Defaults to 0  num : How many results do we want", 
            "title": "paging"
        }, 
        {
            "location": "/python_client/#query95string", 
            "text": "def query_string(self)  Return the query string of this query only", 
            "title": "query_string"
        }, 
        {
            "location": "/python_client/#verbatim", 
            "text": "def verbatim(self)  Set the query to be verbatim, i.e. use no query expansion or stemming", 
            "title": "verbatim"
        }, 
        {
            "location": "/python_client/#class-result", 
            "text": "Represents the result of a search query, and has an array of Document objects", 
            "title": "Class Result"
        }, 
        {
            "location": "/python_client/#9595init9595_9", 
            "text": "def __init__(self, res, hascontent, query_text, duration=0, snippets=None)   snippets : An optional dictionary of the form {field: snippet_size} for snippet formatting", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#class-suggestion", 
            "text": "Represents a single suggestion being sent or returned from the auto complete server", 
            "title": "Class Suggestion"
        }, 
        {
            "location": "/python_client/#9595init9595_10", 
            "text": "def __init__(self, string, score=1.0)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#class-textfield", 
            "text": "TextField is used to define a text field in a schema definition", 
            "title": "Class TextField"
        }, 
        {
            "location": "/python_client/#9595init9595_11", 
            "text": "def __init__(self, name, weight=1.0)", 
            "title": "__init__"
        }, 
        {
            "location": "/python_client/#redis95args_2", 
            "text": "def redis_args(self)", 
            "title": "redis_args"
        }
    ]
}